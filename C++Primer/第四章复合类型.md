-----

### C++ 读书笔记 - 第4章 复合类型

#### 核心概要

本章介绍**复合类型 (Compound Types)**，它们是基于C++基本类型（如`int`, `float`）创建的更复杂的数据结构。本章将重点讨论数组、字符串、结构、共用体、枚举和指针，并引入动态内存管理的概念。复合类型是构建大型程序和实现面向对象编程（OOP）的基础。

-----

#### 1\. 数组 (`array`)

数组是一种可以存储多个**同类型**值的数据结构。计算机在内存中连续、依次地存储数组的各个元素。

##### 1.1 数组的声明与定义

一个数组的声明需要明确三点：

1.  **元素类型**：数组中存储的值是什么类型。
2.  **数组名称**：变量名。
3.  **元素数量**：数组包含多少个元素。

**通用格式**：

```cpp
typeName arrayName[arraySize];
```

**示例**：

```cpp
short months[12]; // 创建一个名为 months 的数组，包含12个 short 类型的元素
```

##### 1.2 数组的关键规则与特性

  * **数组大小 (`arraySize`) 必须是常量**

      * `arraySize` 必须是一个整型**常量**或**常量表达式**（在编译时其值就已知）。
      * **不能是变量**，因为数组的大小在编译时就需要确定。
      * **正确示例**：`int costs[10];`，`const int SIZE = 12; double salaries[SIZE];`
      * **错误示例**：`int n; cin >> n; int expenses[n]; // 不允许!`

  * **元素访问：使用下标 (索引)**

      * 通过方括号 `[]` 和索引值来访问单个数组元素。
      * **C++ 数组从 0 开始索引**。对于一个包含 `n` 个元素的数组，其索引范围为 `0` 到 `n-1`。
      * 示例：对于 `months[12]`，第一个元素是 `months[0]`，最后一个元素是 `months[11]`。

  * ⚠️ **重要：编译器不检查下标是否有效 (边界安全)**

      * C++ 编译器**不会**在编译时检查你使用的数组下标是否在有效范围内。
      * 访问一个不存在的元素（如 `months[12]` 或 `months[-1]`）不会产生编译错误，但这会在程序运行时导致**未定义的行为**：可能破坏内存中的其他数据、导致程序崩溃或产生无法预料的结果。
      * **程序员必须自己负责确保下标的有效性**。

  * **`sizeof` 运算符与数组**

      * `sizeof arrayName`: 返回**整个数组**所占用的总字节数。
      * `sizeof arrayName[0]`: 返回数组中**单个元素**所占用的字节数。
      * 这是一个计算数组元素个数的常用技巧：`int count = sizeof(yams) / sizeof(yams[0]);`

##### 1.3 数组的初始化

  * **基本初始化方法**

      * 使用花括号 `{}` 括起来的、用逗号分隔的**初始化列表**。
      * `int yamcosts[3] = {20, 30, 5};`

  * **初始化规则**

    1.  **只能在定义时初始化**：一旦数组被定义，就不能再使用初始化列表的形式对其进行整体赋值。
        ```cpp
        int cards[4] = {3, 6, 8, 10}; // 正确
        int hand[4];
        hand = cards; // 错误！不能将一个数组赋给另一个数组
        hand[0] = 3; // 正确，可以对单个元素赋值
        ```
    2.  **部分初始化**: 如果提供的初始值数量**少于**数组元素的数量，则剩余的元素会被自动初始化为 **0**。
        ```cpp
        // hotelTips[0]=3, hotelTips[1]=5, 其他48个元素均为0
        float hotelTips[50] = {3.0f, 5.5f};
        ```
    3.  **全部初始化为0的快捷方式**：
        ```cpp
        // 将数组所有50个元素都初始化为0
        long totals[50] = {0};
        ```
    4.  **自动计算大小**：如果在初始化时方括号 `[]` 内为空，编译器会自动计算元素的个数。
        ```cpp
        // 编译器会自动创建包含4个元素的things数组
        short things[] = {1, 5, 3, 8};
        ```

  * **C++11 列表初始化增强**
    C++11 扩展了列表初始化的功能，使其更通用和安全。

    1.  **可省略等号 (`=`)**：
        ```cpp
        double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4}; // C++11
        ```
    2.  **空括号初始化为零**：大括号内没有任何东西，所有元素都会被初始化为0。
        ```cpp
        unsigned int counts[10] {}; // 所有10个元素都初始化为0
        ```
    3.  ⚠️ **禁止缩窄转换 (Narrowing Conversion)**：这是C++11列表初始化的一个重要安全特性。它不允许将可能导致数据丢失的类型转换。
        ```cpp
        // 错误！3.0是浮点型，转换为long是缩窄转换，不允许
        long plifs[] = {25, 92, 3.0};

        // 错误！1122011 超出了char的表示范围，是缩窄转换
        char slifs[] = {'h', 'i', 1122011};

        // 正确。112是int，但在char的表示范围内，不属于缩窄转换
        char tlifs[] = {'h', 'i', 112};
        ```

##### 1.4 数组的替代品

C++ 标准模板库 (STL) 提供了比内置数组更灵活、更安全的替代品，如：

  * **`vector`** (模板类)
  * **`array`** (模板类，C++11新增)
    这些将在后续章节中详细讨论。

-----

#### 2\. C-风格字符串 (C-style Strings)

C++处理字符串有两种方式，第一种是继承自C语言的C-风格字符串。

##### 2.1 核心定义：以空字符结尾的`char`数组

  * **本质**: C-风格字符串是存储在连续内存中的一系列字符，其本质是一个`char`类型的数组。
  * **最重要的特性**: 字符串的末尾必须有一个**空字符 (null character)**，写作 `\0`。
      * 空字符的ASCII码为0。
      * 它的作用是**标记字符串的结束**。所有处理C-风格字符串的函数（如`cout`输出、`strlen`计算长度）都依赖这个`\0`来确定在哪里停止操作。
  * **字符串 vs 普通`char`数组**:
    ```cpp
    char dog[8] = {'b', 'e', 'a', 'u', 'x', ' ', 'I', 'I'}; // 普通char数组
    char cat[8] = {'f', 'a', 't', ' ', 'c', 'a', 't', '\0'}; // C-风格字符串
    ```
      * `cout << dog;` 的行为是未定义的，它会打印`dog`数组的内容，然后继续打印内存中后面的字节，直到偶然遇到一个空字符为止。
      * `cout << cat;` 则会正确地打印 "fat cat"。

##### 2.2 初始化C-风格字符串

  * **字符串字面值 (String Literal)**: 使用双引号 `"` 是初始化字符串最简单、最常用的方法。
    ```cpp
    char bird[11] = "Mr. Cheeps";
    char fish[] = "Bubbles"; // 让编译器自动计算数组大小 (8个字符 + 1个\0 = 9)
    ```
  * **关键点**:
    1.  **自动添加空字符**: 使用字符串字面值进行初始化时，编译器会自动在末尾添加 `\0`。你不需要、也不应该手动添加。
    2.  **数组大小**: 必须确保数组的声明大小足以容纳所有字符**加上一个额外的空字符**。
          * `"wren"` 包含4个字符，但需要大小至少为5的`char`数组来存储。
    3.  **区分 `"` 和 `'`**:
          * `'S'` 是一个 `char` **字符常量**，代表字符S的数值编码（如ASCII 83）。
          * `"S"` 是一个 `char*` **字符串字面值**，代表一个包含两个字符 (`'S'` 和 `'\0'`) 的字符串的内存地址。二者不能混用。

##### 2.3 字符串字面值的拼接

  * C++ 编译器会自动将由空白（空格、制表符、换行符）分隔的字符串字面值拼接成一个。
    ```cpp
    cout << "I'd give my right arm to be" " a great violinist." << endl;
    // 输出: I'd give my right arm to be a great violinist.
    ```
  * **注意**: 拼接操作不会在字符串之间自动添加空格。第一个字符串的 `\0` 会被第二个字符串的第一个字符覆盖。

##### 2.4 字符串常用操作与函数

  * **`strlen()` vs `sizeof()`**: 这是一个非常关键的区别。
      * **`sizeof(arrayName)`**: 返回数组被分配的总内存大小（字节数）。这个值在编译时确定，不会改变。
      * **`strlen(charArray)`**: (位于 `<cstring>` 头文件) 返回字符串中**可见字符**的数量，它从头开始计数，直到遇到 `\0` 为止，**不包括 `\0` 本身**。
    <!-- end list -->
    ```cpp
    char name[15] = "Basicman";
    cout << sizeof(name); // 输出: 15 (数组的总大小)
    cout << strlen(name); // 输出: 8 (字符串 "Basicman" 的长度)
    ```
  * **手动截断字符串**: 你可以通过在字符串中间手动插入 `\0` 来“截断”它。
    ```cpp
    char name[15] = "Basicman";
    name[3] = '\0';
    cout << name; // 输出: Bas
    ```

##### 2.5 字符串的输入：常见问题与解决方案

  * **`cin >>` 的问题**:

      * **行为**: `cin` 使用空白（空格、制表符、换行符）作为分隔符。当读取字符串时，它只读取到第一个空白字符之前的内容。
      * **后果**:
        1.  无法读取包含空格的字符串（如 "Dirk Pitt"）。
        2.  第一个单词后的剩余部分会**留在输入队列（缓冲区）中**，并被下一次 `cin` 读取。

    <!-- end list -->

    ```cpp
    // 输入: Alistair Dreeb
    cin >> name;     // name 中存入 "Alistair"，" Dreeb" 仍留在输入队列
    cin >> dessert;  // dessert 不会等待新输入，直接从队列中读取 "Dreeb"
    ```

  * **面向行的输入: `cin.getline()`**

      * **功能**: 读取一整行输入，直到遇到换行符 (`\n`)。
      * **语法**: `cin.getline(char_array, size);`
      * **行为**:
        1.  最多读取 `size-1` 个字符，为末尾的 `\0` 预留空间。
        2.  读取并**丢弃**输入队列中的换行符 (`\n`)。
      * **优点**: 使用简单，是读取包含空格的字符串的常用方法。

  * **面向行的输入: `cin.get()`**

      * **功能**: 同样可以读取一整行。
      * **语法**: `cin.get(char_array, size);`
      * **行为**:
        1.  与`getline`一样，最多读取 `size-1` 个字符。
        2.  **关键区别**: 它**不会**读取并丢弃换行符，而是将 `\n` **留在输入队列中**。
      * **后果**: 如果紧接着再次调用 `cin.get(another_array, size)`，它会立即读到上次留下的 `\n`，认为已经到达行尾，从而读入一个空字符串。
      * **解决方案**:
        1.  **额外调用 `cin.get()`**: `cin.get()` (不带参数) 会读取并丢弃下一个字符，正好可以用来处理留下的 `\n`。
        2.  **拼接调用**: `cin.get(name, Size).get();` 这是一个常用技巧。

##### 2.6 ⚠️ 混合输入数字和字符串的问题

这是一个非常常见且必须注意的陷阱。

  * **问题场景**: 当使用 `cin >>` 读取一个数字后，紧接着使用 `cin.getline()` 读取一个字符串。
    ```cpp
    int year;
    cout << "Enter a year: ";
    cin >> year; // 用户输入 2025 并按回车
    char address[80];
    cout << "Enter an address: ";

    cin.getline(address, 80); // 这一行会被立即跳过！
    ```
  * **原因**: `cin >> year;` 只读取了数字 `2025`，用户按下的**回车键产生的换行符 (`\n`) 依然留在输入队列中**。当 `cin.getline()` 执行时，它首先看到的就是这个 `\n`，于是认为这是一个空行，立即停止读取。
  * **解决方案**: 在 `cin.getline()` 之前，必须手动清除掉这个换行符。
      * **方法一**: `(cin >> year).get();` (推荐，将调用拼接起来)
      * **方法二**:
        ```cpp
        cin >> year;
        cin.get(); // 单独调用cin.get()来消耗换行符
        ```