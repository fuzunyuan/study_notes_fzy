---

### C++ 读书笔记 - 第3章 处理数据

#### 核心概要

本章主要介绍C++的**基本数据类型**，重点是**整型**和**浮点型**。理解这些内置类型是学习面向对象编程（OOP）中设计自己数据类型的基础。本笔记将主要覆盖变量的定义、命名规则以及C++中的各种整型。

---

#### 1. 简单变量 (Simple Variables)

程序为了存储信息，必须记录三个基本属性：
1.  **存储位置**：信息存放在内存的哪个地方。
2.  **存储的值**：具体是什么数值或内容。
3.  **存储的类型**：是整数、字符还是其他类型。

在C++中，我们通过**声明变量**来实现这一点。例如：`int braincount = 5;`
* `int`：指定了类型为整数。
* `braincount`：是变量的名称（一个符号），代表了存储该值的内存单元。
* `5`：是要存储的具体值。

#### 2. 变量命名规则与约定

##### C++ 命名硬性规则：
* **合法字符**：只能使用字母、数字和下划线 (`_`)。
* **首字符**：第一个字符不能是数字。
* **大小写敏感**：`myVariable` 和 `myvariable` 是两个不同的变量。
* **关键字**：不能使用C++的关键字作为名称（如 `int`, `for`, `class` 等）。
* **保留名称**：
    * 以**两个下划线 (`__`)** 或 **下划线+大写字母 (`_A`)** 开头的名称，被保留给编译器实现使用，应避免使用。
    * 以**一个下划线 (`_`)** 开头的名称，被保留用作全局标识符，也应避免使用。
* **长度**：C++对名称长度没有限制。

##### 命名约定 (编程风格)：
* **提高可读性**：变量名应有意义，如 `cost_of_trip` 而非 `x`。
* **多词组合**：
    * **下划线风格**：`my_onions` (C程序员常用)
    * **驼峰命名法**：`myEyeTooth` (从第二个单词起首字母大写)
* **带类型前缀 (可选)**：一些程序员喜欢在变量名前加上前缀来表明其类型，以增加代码清晰度。
    * `nMyWeight` (n 代表 number/integer)
    * `bIsFinished` (b 代表 boolean)
    * `szName` (sz 代表 a zero-terminated string)
    > 重点：**一致性**和**精确性**是选择命名风格时最重要的原则。

---

#### 3. C++ 内置整型 (Integer Types)

整数是没有小数部分的数字。C++为了满足不同场景的需求，提供了多种整型，它们的主要区别在于**宽度（width）**，即占用的内存空间大小。宽度越大，可表示的整数范围也越大。

##### 3.1 整型分类
C++的基本整型按宽度递增排序为： `char`, `short`, `int`, `long`, `long long` (C++11 新增)。
* 以上每种类型都有**符号 (`signed`)** 版本和**无符号 (`unsigned`)** 版本，总共10种。
* `short` 是 `short int` 的简称。
* `long` 是 `long int` 的简称。
* 默认的 `int`, `short`, `long`, `long long` 都是带符号的。

##### 3.2 整数类型的最小长度保证
为了保证代码的可移植性，C++标准规定了每种整型的最小尺寸：
* `short`：至少16位。
* `int`：至少和 `short` 一样长。
* `long`：至少32位，且至少和 `int` 一样长。
* `long long`：至少64位，且至少和 `long` 一样长。
> **注意**：`int` 的具体大小（如16位或32位）取决于编译器和操作系统，这是跨平台编程时需要注意的问题。

##### 3.3 关键概念：位(bit)与字节(byte)
* **位 (Bit)**：计算机内存的基本单元，值为0或1。
* **字节 (Byte)**：通常指8位的内存单元。
* **C++对字节的定义**：由足以容纳实现的基本字符集的相邻位组成。在大多数系统中，一个字节是8位，但标准允许更大的字节（如16位或32位）以支持Unicode等大型字符集。

---

#### 4. 检查系统上的整型属性

我们可以使用C++提供的工具来查看在特定系统上整型的具体大小和取值范围。

##### 4.1 `sizeof` 运算符
* **功能**：返回一个类型或一个变量所占用的**字节数**。
* **用法**：
    * 对类型名使用：`sizeof(int);` （必须有括号）
    * 对变量名使用：`sizeof n_short;` （括号可选）

##### 4.2 `<climits>` 头文件
* **功能**：包含关于整型限制的信息，定义了一系列表示各种类型极限值的**符号常量**。
* **常用常量示例**：
    * `CHAR_BIT`：一个字节的位数。
    * `INT_MAX`：`int` 类型的最大值。
    * `INT_MIN`：`int` 类型的最小值。
    * `LONG_MAX`：`long` 类型的最大值。
    * `LLONG_MAX`：`long long` 类型的最大值。

---

#### 5. 符号常量 (Symbolic Constants)

##### 预处理器方式：`#define`
* 这是从C语言继承的一种创建符号常量的方式。
* **工作原理**：`#define INT_MAX 32767` 告诉预处理器，在编译前，将代码中所有的 `INT_MAX` 文本替换为 `32767`。
* **现代C++实践**：虽然头文件（如`<climits>`）中仍在使用 `#define`，但在我们自己的代码中，C++推荐使用 `const` 关键字来创建常量，因为它提供了更好的类型安全。
好的，这是接续上一部分的读书笔记。

-----

#### 6. 变量的初始化 (Variable Initialization)

初始化是在声明变量的同时为其赋一个初始值。**强烈建议在声明时就进行初始化**，以避免变量持有不确定的、无意义的“垃圾值”。

##### 6.1 初始化方式汇总

C++支持多种初始化语法：

1.  **C语言风格初始化 (C-style Initialization)**
    使用等号 `=`，这是最常见和传统的方式。

    ```cpp
    int uncles = 5;
    int aunts = uncles; // 可以用已定义的变量初始化
    int chairs = uncles + aunts; // 可以用表达式初始化
    ```

2.  **C++特定语法 (Constructor-style Initialization)**
    使用圆括号 `()`。

    ```cpp
    int wrens(432);
    ```

3.  **C++11 通用初始化 (Uniform Initialization)**
    使用大括号 `{}`，也称为“列表初始化”。这是C++11提倡的、可以适用于所有类型的通用方法。

      * **形式一：带等号**
        ```cpp
        int owls = {101};
        ```
      * **形式二：不带等号**
        ```cpp
        int rocs{101};
        ```
      * **零初始化 (Zero-initialization)**：如果大括号内为空，变量会被初始化为零。
        ```cpp
        int a{}; // a 被初始化为 0
        ```
      * **优点**：
          * **语法统一**：对任何类型（普通变量、数组、类）都适用。
          * **更安全**：有助于防止某些类型的类型转换错误。

> **警告**：如果一个定义在函数内部的变量没有被初始化，它的值将是**不确定**的。

-----

#### 7. 无符号整型 (`unsigned`)

  * **定义**：通过 `unsigned` 关键字修饰的整型，不能存储负数。
  * **语法**：`unsigned short sue;`
      * `unsigned` 本身是 `unsigned int` 的简写。
  * **优点**：在同样的内存空间下，由于不需要表示负数，其能存储的最大正数值大约是对应有符号整型的两倍。
      * 例如：`short` 范围是 `-32768` 到 `32767`，而 `unsigned short` 的范围是 `0` 到 `65535`。
  * **应用场景**：适用于那些值永远不会为负的场景，如人口数量、物品计数等。
  * **溢出行为 (Overflow/Underflow)**：
      * 无符号整型的行为像一个“里程表”。当值超出其表示范围时，会发生**回绕 (wrap around)**。
      * `unsigned short` 变量值为 `65535`，加 1 后会变为 `0`。
      * `unsigned short` 变量值为 `0`，减 1 后会变为 `65535`。
      * **C++标准保证了无符号整型的这种回绕行为**。而有符号整型的溢出在标准中是未定义行为。

-----

#### 8. 如何选择整型类型？(Practical Guide)

| 类型 | 推荐使用场景 | 原因 |
| :--- | :--- | :--- |
| **`int`** | **默认首选** | 是计算机处理效率最高的“自然长度”，除非有特殊需求，否则应优先使用。 |
| **`unsigned`** | 变量值**绝不为负**时 | 可以表示更大的正数范围。 |
| **`long`** | 存储的值可能**超过16位整数**的范围 (约32767) | 保证代码在16位系统和32位系统之间移植时的正确性。 |
| **`long long`** | 存储的值可能**超过`long`的范围 (约20亿) | 用于表示非常大的整数。 |
| `short` | 内存非常宝贵时，尤其是在大型数组中 | 可以节省内存空间。即使`short`和`int`长度相同，使用`short`也能在移植到`int`更长的系统时保持内存占用不变。 |
| `char` | 只需要一个字节**的存储空间时 | 最节省空间的整型。 |

-----

#### 9\. 整型字面值 (Integer Literals)

字面值是直接写在代码中的常量。C++支持多种进制来书写整型字面值。

| 进制 | 前缀 | 示例 | 十进制值 |
| :--- | :--- | :--- | :--- |
| **十进制 (Decimal)** | 无 (首位是 1-9) | `93` | 93 |
| **八进制 (Octal)** | `0` (零) | `042` | 34 |
| **十六进制 (Hexadecimal)** | `0x` 或 `0X` | `0x42` | 66 |

> **核心思想**：无论字面值以何种进制书写，它们在计算机内存中都以**二进制**形式存储。使用不同进制只是为了方便程序员读写。

-----

#### 10\. 控制 `cout` 的输出格式

默认情况下，`cout` 以十进制显示整数。可以使用 `<iostream>` 头文件中提供的**控制符 (manipulators)** 来改变输出的进制格式。

  * **`dec`**：切换到十进制模式。
  * **`hex`**：切换到十六进制模式。
  * **`oct`**：切换到八进制模式。

**示例**：

```cpp
#include <iostream>

int main() {
    using namespace std;
    int chest = 42;

    cout << "Decimal: " << chest << endl;       // 默认十进制
    cout << "Hexadecimal: " << hex << chest << endl; // 切换到十六进制
    cout << "Octal: " << oct << chest << endl;       // 切换到八进制
    cout << "Decimal again: " << dec << chest << endl; // 切换回十进制
    return 0;
}
```

**重要特性**：

  * 控制符 `hex`, `oct`, `dec` 本身不输出任何内容，它们只是**修改 `cout` 对象的状态**。
  * 这种状态改变是\*\*“粘性的”\*\*，一旦设置，后续所有整数输出都会沿用该格式，直到遇到下一个进制控制符。
  * 这些控制符位于 `std` 命名空间中。
好的，这是接续之前内容的读书笔记。

-----

#### 11\. 整型常量的类型 (Type of Integer Constants)

C++编译器如何确定一个像 `1492` 这样的数字字面值属于哪种整型？规则如下：

##### 11.1 使用后缀明确指定类型

可以在数字后面添加后缀，来显式地告诉编译器其类型。

| 后缀 | 代表类型 | 示例 |
| :--- | :--- | :--- |
| `l` 或 `L` | `long` | `22022L` (推荐大写L) |
| `u` 或 `U` | `unsigned int` | `22022U` |
| `ul` 或 `UL` | `unsigned long` | `22022UL` |
| `ll` 或 `LL` | `long long` (C++11) | `3000000000LL` |
| `ull` 或 `ULL` | `unsigned long long` (C++11) | `22022ULL` |

##### 11.2 无后缀常量的默认类型

如果一个整型常量没有后缀，编译器会根据其大小，为其选择**能容纳该值的最小类型**。

  * **十进制整数**：会依次尝试 `int` -\> `long` -\> `long long`。
      * `20000` -\> `int` (若 `int` 为16位或以上)
      * `40000` -\> `long` (若 `int` 为16位，无法容纳)
  * **十六进制/八进制整数**：会依次尝试 `int` -\> `unsigned int` -\> `long` -\> `unsigned long` -\> `long long` -\> `unsigned long long`。
      * 使用 `unsigned` 类型是因为十六进制常用于表示无符号的内存地址。

-----

#### 12\. `char` 类型：字符和小整数

`char` 类型是另一种整型，专门设计用来存储字符，如字母、数字和标点符号。

##### 12.1 基本概念

  * **本质**：`char` 存储的是字符对应的**数值编码**（如 ASCII 码）。它是一种整型，其长度足以容纳计算机系统中的所有基本符号（通常是8位）。
  * **用途**：既可以作为字符使用，也可以作为比 `short` 更小的整型使用。
  * **字符字面值**：用**单引号**括起来，如 `'M'`。它代表的是字符的数值编码（在ASCII中，`'M'` 代表 `77`）。

##### 12.2 `cin` / `cout` 的特殊处理

`cin` 和 `cout` 非常智能，它们会根据变量的类型来决定如何解释和显示数据。

  * `char ch = 'M'; int i = ch;`
  * `cout << ch;` 会显示字符 **M**。
  * `cout << i;` 会显示数字 **77**。

> `cout` 看到变量是 `char` 类型，就会将其值作为字符编码来解释并显示对应的字符。看到是 `int` 类型，就直接显示数字。

##### 12.3 成员函数 `cout.put()`

  * 这是 C++ OOP（面向对象编程）中**成员函数**的第一个例子。
  * **语法**：`对象名.成员函数名()`，例如 `cout.put('M');`
  * **功能**：专门用于输出一个字符。可以替代 `<<` 运算符来显示字符。

##### 12.4 转义序列 (Escape Sequences)

对于无法从键盘直接输入或有特殊含义的字符，C++提供了转义序列。

| 名称 | C++ 代码 | 功能 |
| :--- | :--- | :--- |
| 换行符 | `\n` | 移动到下一行开头 |
| 水平制表符 | `\t` | 水平跳格 (Tab) |
| 退格 | `\b` | 光标后退一格 |
| 振铃 | `\a` | 发出系统提示音 |
| 反斜杠 | `\\` | 显示一个反斜杠 `\` |
| 单引号 | `\'` | 显示一个单引号 `'` |
| 双引号 | `\"` | 显示一个双引号 `"` |

  * **数字表示法**：也可以用八进制 (`\032`) 或十六进制 (`\x1a`) 编码来表示字符。
    > **提示**：应优先使用符号表示（如 `\b`），因为它比数字表示（如 `\0x8`）更具可读性和可移植性。

##### 12.5 `signed char` 与 `unsigned char`

  * `char` 类型默认是**有符号还是无符号由编译器实现决定**。
  * 如果需要明确其数值范围，应显式声明：
      * `signed char`: 范围通常是 -128 到 127。
      * `unsigned char`: 范围通常是 0 到 255。
  * 如果只是用 `char` 存储标准ASCII字符，则无需关心其符号性。如果用作数值类型，则应明确指定。

##### 12.6 宽字符与新字符类型

为了支持超出8位字节表示范围的字符集（如Unicode），C++提供了其他字符类型。

| 类型 | 字面值前缀 | 位数 | 用途 |
| :--- | :--- | :--- | :--- |
| `wchar_t` | `L` | 实现定义 | 宽字符类型，用于扩展字符集 |
| `char16_t` (C++11) | `u` | 16位 (无符号) | 用于16位的Unicode字符 |
| `char32_t` (C++11) | `U` | 32位 (无符号) | 用于32位的Unicode字符 |

-----

#### 13\. `bool` 类型

  * **用途**：用于表示逻辑值：**真**或**假**。
  * **字面值**：`true` 和 `false`。
  * **与整型转换**：
      * `bool` -\> `int`：`true` 转换为 `1`，`false` 转换为 `0`。
      * 数字/指针 -\> `bool`：**任何非零值**都转换为 `true`，**零值**转换为 `false`。

**示例**：

```cpp
bool is_ready = true;
int ans = true;          // ans 的值为 1
bool start = -100;       // start 的值为 true
bool stop = 0;           // stop 的值为 false
```

-----

#### 14\. `const` 限定符

`const` 是C++中创建**符号常量**的首选方法，它优于C语言的 `#define`。

  * **定义**：`const` 是一个限定符，它限定一个变量被初始化后，其值**不能再被修改**。
  * **通用格式**：
    ```cpp
    const type name = value;
    ```
  * **示例**：
    ```cpp
    const int MONTHS = 12; // 创建一个名为 MONTHS 的整型常量
    ```
  * **重要规则**：`const` 常量必须在**声明时进行初始化**。

##### `const` 优于 `#define` 的原因：

1.  **明确类型**：`const` 常量有明确的数据类型，而 `#define` 只是简单的文本替换。
2.  **遵守作用域规则**：`const` 常量可以被限制在特定的作用域内（如函数内），而 `#define` 从定义点到文件结尾都有效。
3.  **适用于复杂类型**：`const` 可以用于数组、结构体等更复杂的数据类型。

> **核心建议**：在C++中，应使用 `const` 来定义符号常量，而不是 `#define`。
好的，这是最后一章内容的读书笔记。

-----

#### 15\. 浮点数 (Floating-Point Numbers)

浮点数是C++的第二组基本类型，用于表示带小数部分的数字，以及非常大或非常小的数值。

##### 15.1 基本概念

计算机将浮点数分为两部分存储：

1.  **尾数 (Mantissa)**：表示值中的有效数字，如 `0.341245`。
2.  **指数 (Exponent)**：用于对尾数进行缩放（放大或缩小），相当于移动小数点的位置。

> 这种表示方法使得小数点的位置可以“浮动”，因此得名“浮点数”。

##### 15.2 书写方式

1.  **标准小数点表示法**：最常用的写法。
    ```cpp
    12.34
    0.00023
    8.0  // 小数点确保其为浮点类型
    ```
2.  **E 表示法 (科学计数法)**：用于表示极大或极小的数。
      * 格式：`尾数E指数`，代表 `尾数` 乘以 `10` 的 `指数` 次方。
      * `3.45E6`  -\>  `3.45 * 10^6`  -\>  `3450000`
      * `2.52e+8` -\>  `2.52 * 10^8`  -\>  `252000000`
      * `8.33E-4` -\>  `8.33 * 10^-4` -\>  `0.000833`
      * E可以写作 `e`，指数可以是正数或负数，但数字中间不能有空格。

##### 15.3 浮点类型 (`float`, `double`, `long double`)

C++提供三种浮点类型，主要区别在于\*\*精度（有效位数）\*\*和范围。

| 类型 | 通常位数 | 精度（有效位数） | 说明 |
| :--- | :--- | :--- | :--- |
| `float` | 32位 | 至少6位 | 精度最低，占用内存最小。 |
| `double`| 64位 | 至少15位 | 精度和范围居中，是**默认的浮点类型**。 |
| `long double`| 80, 96 或 128位 | 通常比 `double` 更高 | 精度最高，占用内存最大。 |

  * 可以在头文件 `<cfloat>` 中找到系统对浮点类型的具体限制。

##### 15.4 浮点常量与后缀

  * **默认类型**：代码中直接书写的浮点字面值（如 `3.14`）默认为 `double` 类型。
  * **后缀**：
      * `f` 或 `F`：指定常量为 `float` 类型 (e.g., `3.14f`)。
      * `l` 或 `L`：指定常量为 `long double` 类型 (e.g., `3.14L`)。

##### 15.5 优缺点

  * **优点**：
    1.  可以表示整数之间的小数。
    2.  表示的数值范围远大于整型。
  * **缺点**：
    1.  浮点运算通常比整数运算慢。
    2.  **精度损失**：存在舍入误差，无法像整数一样精确。例如，一个非常大的浮点数加上一个很小的数，结果可能不会有任何变化。

-----

#### 16\. C++ 算术运算符

| 运算符 | 名称 | 功能 | 示例 |
| :--- | :--- | :--- | :--- |
| `+` | 加法 | 将两个操作数相加 | `4 + 20` -\> `24` |
| `-` | 减法 | 从第一个数中减去第二个数 | `12 - 3` -\> `9` |
| `*` | 乘法 | 将两个操作数相乘 | `28 * 4` -\> `112` |
| `/` | 除法 | 用第一个数除以第二个数 | `1000 / 5` -\> `200` |
| `%` | 求模 | 返回整数除法的余数 | `19 % 6` -\> `1` |

##### 16.1 运算符优先级与结合性

  * **优先级 (Precedence)**：决定哪个运算符先执行。`*`、`/`、`%` 的优先级高于 `+`、`-`。
      * `3 + 4 * 5` 会被计算为 `3 + (4 * 5)`，结果是 `23`。
  * **结合性 (Associativity)**：当运算符优先级相同时，决定执行顺序。算术运算符是**从左到右**结合。
      * `120 / 4 * 5` 会被计算为 `(120 / 4) * 5`，结果是 `150`。

##### 16.2 除法 (`/`) 的分支

除法运算符的行为取决于操作数的类型，这是一个**运算符重载**的例子。

  * **整数除法**：如果两个操作数都是整型，结果也是整型，小数部分会被**截断**（直接丢弃）。
      * `17 / 3` 的结果是 `5`。
  * **浮点除法**：如果至少有一个操作数是浮点类型，结果将是浮点类型，保留小数部分。
      * `17.0 / 3` 的结果是 `5.6666...`。

##### 16.3 求模运算符 (`%`)

  * **规则**：操作数**必须是整型**。
  * **功能**：返回整数除法的余数。
  * **应用**：非常适合用于单位换算等需要余数的问题，例如将磅转换为英石和磅。

-----

#### 17\. 类型转换 (Type Conversions)

C++会在很多情况下自动进行类型转换，但有时也需要我们手动进行强制转换。

##### 17.1 自动 (隐式) 类型转换

1.  **赋值与初始化时**：
      * 一个值赋给不同类型的变量时，会被转换为该变量的类型。
      * **潜在问题**：
          * 范围大的类型 -\> 范围小的类型，可能导致数据丢失或值不确定（如 `long` -\> `short`）。
          * 浮点类型 -\> 整型，小数部分会被**截断**（如 `3.9832` 变为 `3`）。
2.  **C++11 列表初始化 `{}`**：
      * 这种初始化方式**不允许缩窄 (narrowing)** 转换，即可能会丢失数据的转换。这是一种更安全的初始化方法。
          * `int x = {3.14};`  // 编译错误
          * `int y{10000000000};` // 在 `int` 为32位的系统上编译错误
3.  **表达式中**：
      * **整型提升 (Integral Promotion)**：在表达式中，`bool`, `char`, `short` 等类型通常会自动提升为 `int` 类型进行计算。
      * **混合类型算术**：当一个表达式中包含不同类型时，较小的类型会被转换为较大的类型，遵循一个固定的转换级别（`float` -\> `double` -\> `long double`）。

##### 17.2 强制 (显式) 类型转换 (Casting)

当我们想覆盖C++的自动转换规则时，可以使用强制类型转换。

1.  **C 语言风格**：`(type) value`
    ```cpp
    int a = (int) 19.99; // a 的值为 19
    ```
2.  **函数风格 (C++)**：`type(value)`
    ```cpp
    int b = int(11.99); // b 的值为 11
    ```
3.  **`static_cast` 运算符 (现代C++)**：`static_cast<type>(value)`
    ```cpp
    int c = static_cast<int>(31.98); // c 的值为 31
    ```

> **推荐用法**：`static_cast` 是现代C++中推荐的用法，因为它在编译时会进行更严格的类型检查，比C语言风格的强制转换更安全。

  * **常见用途**：
    1.  在计算过程中，根据需要临时改变值的类型。
    2.  满足特定的函数或操作要求，例如，强制将 `char` 类型的值转换为 `int` 来打印其ASCII码。
好的，这是本章最后一部分内容的读书笔记。

-----

##### 17.3 C++11 中的 `auto` 声明

C++11 重新定义了 `auto` 关键字，使其成为一种新的类型推断工具。

  * **功能**：当用 `auto` 声明变量时，编译器会根据**初始化表达式的类型**来自动推断该变量的类型。
  * **语法**：
    ```cpp
    auto n = 100;       // n 的类型是 int
    auto x = 1.5;       // x 的类型是 double
    auto y = 1.3e12L;   // y 的类型是 long double
    ```
  * **主要目的**：`auto` 并非旨在替代简单的类型声明（如 `int`），其真正威力在于**简化复杂类型的声明**，尤其是标准模板库（STL）中的长类型名，如迭代器。
      * **C++98 风格**:
        ```cpp
        std::vector<double> scores;
        std::vector<double>::iterator pv = scores.begin();
        ```
      * **C++11 `auto` 风格**:
        ```cpp
        std::vector<double> scores;
        auto pv = scores.begin(); // 简洁明了
        ```

> **注意**：`auto` 的类型推断完全依赖于初始值。`auto z = 0;` 会将 `z` 推断为 `int`，而 `auto z = 0.0;` 则会将 `z` 推断为 `double`。

-----

### 18\. 本章总结 (Chapter Summary)

1.  **基本类型**：C++的基本类型分为**整型**和**浮点型**两大组。

2.  **整型 (Integer Types)**：

      * **种类**：包括 `bool`, `char`, `short`, `int`, `long`, `long long` 及其 `unsigned` 版本。此外还有宽字符类型 `wchar_t`, `char16_t`, `char32_t`。
      * **大小保证**：`short` ≥ 16位, `int` ≥ `short`, `long` ≥ 32位且 ≥ `int`。
      * **字符**：本质上也是整型，通过其数值编码（如ASCII）来表示。

3.  **浮点型 (Floating-Point Types)**：

      * **种类**：`float`, `double`, `long double`。
      * **大小关系**：`float` 的精度不高于 `double`，`double` 的精度不高于 `long double`。
      * **默认类型**：浮点常量（如 `3.14`）默认为 `double`。

4.  **算术运算符**：

      * 提供 `+`, `-`, `*`, `/`, `%` 五种基本算术运算。
      * 遵循**优先级**和**结合性**规则来确定复杂表达式的计算顺序。

5.  **类型转换**：

      * **自动转换**：在赋值、混合类型运算时发生，通常是安全的“提升”转换，但也可能因“缩窄”而丢失数据。
      * **强制转换**：允许程序员显式指定类型转换，现代C++推荐使用更安全的 `static_cast`。

---
