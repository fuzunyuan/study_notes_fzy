## unique_ptr 设计
| 代表对于资源的独占所有权
1. 核心机制：
    1. 模板化，应该是一个类模板，以便它可以管理任何类型的指针
    2. 包装裸指针，内部持有一个T* m_ptr 成员
    3. RAII （资源获取即初始化）
    4. 独占所有权，核心:
        + 禁止拷贝，必须删除拷贝构造函数和拷贝赋值运算符
        + 实现移动，必须实现移动构造函数和移动赋值运算符，当移动发生时，新的unique_ptr 接管裸指针，旧的unique_ptr内部的指针被设为nullptr
## 关键点说明
1. explicit 构造函数：这是为了安全，防止 new int(5) 这样的裸指针被意外地隐式转换为 MyUniquePtr。

2. delete 拷贝操作：这是 unique_ptr 语义的核心。它保证了在任何时候，只有一个 MyUniquePtr 实例可以“拥有”该资源。

3. noexcept 移动操作：移动构造和移动赋值被标记为 noexcept。这对于 C++ 标准库中的容器（如 std::vector）至关重要。如果 vector 扩容时需要移动元素，它会检查移动构造函数是否是 noexcept 的。如果是，它会安全地“移动”元素；如果不是，它会回退到“拷贝”元素（这在 unique_ptr 上是不允许的），导致编译错误。

4. reset 和 release：reset 用于“重置”指针，让它管理一个新资源（并销毁旧资源）。release 则是彻底“释放”所有权，将裸指针返回给调用者，MyUniquePtr 不再管理它。