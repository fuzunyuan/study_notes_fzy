当然，Kubernetes (K8s) 是云原生领域的重中之重。下面我将为你梳理一套**从基础到进阶，再到生产实践**的 K8s 高频面试题，并提供可以直接回答的精炼答案和深度解析。

---

### **第一部分：核心概念与架构 (必会基础)**

#### **问题一：Kubernetes 是什么？它解决了什么核心问题？**

> **一句话摘要：**
> “Kubernetes 是一个开源的**容器编排平台**，它能自动化地部署、扩展和管理容器化应用程序。它解决了在生产环境中大规模运行容器的**复杂性**和**可靠性**问题。”

> **深度解读 (解决的问题):**
> 1.  **自动部署与发布：** 无需手动在每台服务器上部署应用，K8s 帮你搞定。支持滚动更新、灰度发布、金丝雀发布等多种策略。
> 2.  **服务发现与负载均衡：** Pod 的 IP 地址是动态变化的，K8s 通过 Service 机制提供一个稳定的服务入口，并自动进行负载均衡。
> 3.  **弹性伸缩 (Autoscaling):** 可以根据 CPU、内存等指标自动增加或减少应用的副本数 (Pod)，也可以自动增删集群节点。
> 4.  **自我修复 (Self-healing):** 当某个容器或 Pod 崩溃时，K8s 会自动重启或替换它。当某个物理节点宕机时，会自动将该节点上的 Pod 调度到其他健康节点上。
> 5.  **配置与密钥管理：** 通过 ConfigMap 和 Secret 统一管理应用的配置和敏感信息，实现配置与代码的分离。

---

#### **问题二：请描述一下 Kubernetes 的核心组件及其作用。**

> **一句话摘要：**
> “K8s 架构分为**控制平面 (Control Plane)** 和**工作节点 (Worker Node)**。控制平面是集群的‘大脑’，负责决策和管理；工作节点是‘身体’，负责运行实际的应用容器。”

> **深度解读 (组件列表):**
> **控制平面 (Master 节点) 组件：**
> * `kube-apiserver`: **集群的统一入口**。所有组件都通过它进行通信，它提供了 REST API，并负责认证、授权、准入控制等。
> * `etcd`: **分布式键值存储**。作为 K8s 的数据库，存储了集群所有的状态数据（如 Pod、Service 的定义和状态）。
> * `kube-scheduler`: **调度器**。负责监视新创建的、未指定节点的 Pod，并根据资源需求、亲和性、污点等策略，为它们选择一个最佳的 Worker 节点。
> * `kube-controller-manager`: **控制器管理器**。运行着各种控制器（如 Deployment 控制器、Node 控制器），持续地将集群的当前状态调整为期望状态。

> **工作节点 (Worker Node) 组件：**
> * `kubelet`: **节点的“管家”**。每个 Node 上都有一个 kubelet，它负责接收 API Server 的指令，管理本节点上 Pod 和容器的生命周期（创建、销毁等）。
> * `kube-proxy`: **网络代理**。负责维护节点上的网络规则，实现了 Service 的服务发现和负载均衡。
> * `容器运行时 (Container Runtime)`: **运行容器的基础**。如 `containerd`、`CRI-O`。负责镜像管理和容器的实际运行。

---

### **第二部分：核心对象与工作负载 (日常使用)**

#### **问题三：Pod 是什么？为什么不直接使用容器？**

> **一句话摘要：**
> “Pod 是 Kubernetes 中**最小的部署和调度单元**。它不是直接运行容器，而是**包含一个或多个紧密关联的容器**。引入 Pod 是为了更好地管理‘原子性’的应用单元。”

> **深度解读:**
> * **为什么需要 Pod：** 单个容器通常只运行一个进程。但在很多场景下，一组进程需要**紧密协作、共享资源**。
> * **Pod 的特性：**
>     1.  **资源共享：** Pod 内的所有容器共享同一个**网络命名空间**（同一个 IP 地址和端口空间）和**存储卷 (Volume)**。它们之间可以通过 `localhost` 直接通信。
>     2.  **原子性：** Pod 是一个原子单元。它要么被完整地调度到一个节点上，要么不被调度。它的生命周期是统一的，要么一起启动，要么一起销毁。
> * **举例：**
>     * 一个主应用容器 + 一个 Sidecar 容器（如日志收集、服务网格代理）。这两个容器需要共享网络和文件系统，将它们放在一个 Pod 里是完美的解决方案。

---

#### **问题四：Deployment 和 StatefulSet 有什么区别？**

> **一句话摘要：**
> “Deployment 用于部署**无状态应用**，Pod 的名称和身份是随机的，可以任意扩缩容；StatefulSet 用于部署**有状态应用**，Pod 拥有稳定、唯一的身份标识，并且启停和扩缩容是有序的。”

> **深度解读 (表格对比):**
| 特性 | Deployment (用于无状态服务) | StatefulSet (用于有状态服务) |
| :--- | :--- | :--- |
| **Pod 标识** | 随机字符串后缀，如 `myapp-6ff...` | 稳定、有序的标识，如 `db-0`, `db-1` |
| **网络标识** | Pod 重启后 IP 会变 | 拥有稳定的网络标识 (Headless Service) |
| **存储** | 共享同一个 PVC，或不使用持久存储 | 每个 Pod 绑定一个独立的 PVC |
| **启停顺序** | 并行、无序 | 按 Pod 序号顺序启动 (0, 1, 2...)，逆序销毁 (2, 1, 0...) |
| **扩缩容** | 任意增删副本 | 按顺序进行 |
| **适用场景** | Web 服务器 (Nginx)、API 服务 (Go/Java) | 数据库 (MySQL, PostgreSQL)、消息队列 (Kafka) |

---

#### **问题五：Service 有哪几种类型？它们是如何工作的？**

> **一句话摘要：**
> “Service 为一组功能相同的 Pod 提供了**一个统一、稳定的访问入口**。主要有 `ClusterIP`、`NodePort` 和 `LoadBalancer` 三种类型，用于解决不同场景下的服务发现问题。”

> **深度解读:**
> * **`ClusterIP` (默认类型):**
>     * **作用：** 只在**集群内部**暴露服务。K8s 会为 Service 分配一个虚拟的 Cluster IP，集群内的其他 Pod 可以通过这个 IP 访问服务。
>     * **工作原理：** `kube-proxy` 会在每个节点上维护 `iptables` 或 `IPVS` 规则，将访问 Cluster IP 的流量转发到后端健康的 Pod 上。
>
> * **`NodePort`:**
>     * **作用：** 在 ClusterIP 的基础上，在**每个工作节点的物理 IP 上**暴露一个静态端口。这样就可以通过 `<NodeIP>:<NodePort>` 从**集群外部**访问服务。
>     * **适用场景：** 主要用于开发和测试环境，或者当外部负载均衡器不受 K8s 管理时。
>
> * **`LoadBalancer`:**
>     * **作用：** 这是暴露服务到**公网**的标准方式。它会在 NodePort 的基础上，向**云服务商 (如 AWS, GCP, Azure)** 申请一个外部负载均衡器，并将流量导向所有节点的 NodePort。
>     * **适用场景：** 生产环境中需要对外提供服务的标准做法。
>
> * **Ingress (补充):**
>     * Service 工作在 TCP/IP (四层)，而 Ingress 工作在 HTTP/HTTPS (七层)。它不是 Service 的一种类型，而是管理外部访问的**规则集合**。可以通过一个公网 IP 和负载均衡器，根据域名或 URL 路径，将流量路由到不同的 Service，功能更强大、更节省成本。

---

### **第三部分：生产实践与故障排查**

#### **问题六：如何排查一个处于 `Pending` 状态的 Pod？**

> **一句话摘要：**
> “Pod `Pending` 意味着它还**没有被成功调度到任何节点上**。排查时，首先使用 `kubectl describe pod <pod-name>` 查看事件 (Events)，这通常会直接给出原因。”

> **深度解读 (常见原因):**
> 1.  **资源不足 (Insufficient resources):**
>     * **现象：** 事件中提示 `0/3 nodes are available: 3 Insufficient cpu/memory`。
>     * **解决：** 检查 Pod 的 `requests` 是否过高，或者集群节点资源是否已经耗尽。可以尝试删除不必要的 Pod 或为集群扩容。
> 2.  **调度策略不匹配 (Scheduling constraints):**
>     * **现象：** 事件中提示 `0/3 nodes are available: 3 node(s) didn't match node selector/affinity`。
>     * **解决：** 检查 Pod 定义中的 `nodeSelector`、`nodeAffinity` 是否写错，或者集群中是否有满足条件的节点。
> 3.  **节点存在污点 (Taints):**
>     * **现象：** 事件中提示 `0/3 nodes are available: 3 node(s) had taints that the pod didn't tolerate`。
>     * **解决：** 检查节点是否被打上了污点 (`kubectl describe node <node-name>`)，需要在 Pod 中添加对应的容忍 (`tolerations`)。
> 4.  **持久卷未绑定 (PersistentVolumeClaim not bound):**
>     * **现象：** 事件中提示 `pod has unbound immediate PersistentVolumeClaims`。
>     * **解决：** 检查 PVC 的状态 (`kubectl get pvc`)，看是否有满足条件的 PV 可用。

#### **问题七：Liveness Probe 和 Readiness Probe 的区别是什么？为什么需要它们？**

> **一句话摘要：**
> “**Liveness Probe (存活探针)** 用于判断容器是否还‘活着’，如果失败，`kubelet` 会**重启容器**。**Readiness Probe (就绪探针)** 用于判断容器是否已‘准备好’接收流量，如果失败，`kubelet` 会将 Pod 从 Service 的后端端点中**移除**。”

> **深度解读:**
> * **Liveness Probe (存活探针):**
>     * **目的：** 解决“应用假死”的问题。有时候进程还在，但已经无法正常工作（如死锁）。
>     * **行为：** 探测失败 → 重启容器。
>     * **例子：** 一个 Web 服务因为内存泄漏而无法响应请求，但进程仍在。Liveness Probe 可以检测到 HTTP 请求超时，并触发重启，使其恢复服务。
>
> * **Readiness Probe (就绪探针):**
>     * **目的：** 确保流量不会被转发到尚未准备好的 Pod。
>     * **行为：** 探测失败 → 从 Service Endpoint 列表中移除该 Pod 的 IP。
>     * **例子：** 一个 Java 应用启动需要 1 分钟加载数据。在此期间，它虽然在运行（Liveness Probe 通过），但还不能处理业务请求。Readiness Probe 可以等到数据加载完毕后再返回成功，这时 Service 才开始向它转发流量。
>
> **为什么需要：** 这两种探针是构建**健壮、自愈**系统的关键。它们让 K8s 能够更精细地了解应用的状态，并据此做出正确的管理动作（重启或隔离），从而大大提高服务的可用性。
>
> 好的，我们来把 Python 装饰器 (Decorator) 这个强大的概念彻底讲清楚。

我会按照 **“一句话理解 → 核心原理 → 动手实现 → 实际应用”** 的顺序来解释。

-----

### **1. 一句话理解装饰器**

> 装饰器本质上是一个**函数**，它接收另一个函数作为输入，并**在不修改原函数代码的情况下**，为它增加额外的功能，最后返回一个新的函数。

它就像一个“包装工”，你把一个普通函数（货物）扔进去，它给你返回一个包装好的、功能更强的函数（精美礼品）。

它的语法糖是 `@` 符号，写在函数定义的上一行。

```python
@my_decorator
def say_hello():
    print("Hello!")

# 上面的代码完全等价于下面这行：
# say_hello = my_decorator(say_hello)
```

-----

### **2. 核心原理：理解两个前置知识**

要理解装饰器，必须先明白 Python 中的两个特性：

#### **特性一：函数是“一等公民” (First-Class Citizens)**

这意味着函数和其他数据类型（如整数、字符串）一样，可以被：

1.  赋值给一个变量
2.  作为参数传递给另一个函数
3.  作为另一个函数的返回值

<!-- end list -->

```python
def greet(name):
    return f"Hello, {name}"

# 1. 赋值给变量
say_hello = greet
print(say_hello("Alice"))  # 输出: Hello, Alice

# 2. 作为参数传递
def process_function(func, value):
    return func(value)

print(process_function(greet, "Bob")) # 输出: Hello, Bob

# 3. 作为返回值
def get_greeter():
    return greet

greeter_func = get_greeter()
print(greeter_func("Charlie")) # 输出: Hello, Charlie
```

#### **特性二：闭包 (Closure)**

闭包是指一个**能够记住并访问其外部函数作用域**的内层函数，即使外部函数已经执行完毕。

```python
def outer_function(msg):
    # 这是外部函数作用域的变量
    message = msg

    def inner_function():
        # 内层函数可以访问外部的 'message' 变量
        print(message)

    return inner_function

# a_func 是一个闭包，它“记住”了 message = "Hi"
a_func = outer_function("Hi")
a_func()  # 输出: Hi

# b_func 是另一个闭包，它“记住”了 message = "Hello"
b_func = outer_function("Hello")
b_func()  # 输出: Hello
```

**装饰器正是巧妙地运用了“函数是一等公民”和“闭包”这两个特性。**

-----

### **3. 动手实现一个简单的装饰器**

我们来写一个最简单的装饰器，它的功能是在函数执行前后打印日志。

#### **步骤 1: 定义装饰器函数**

装饰器函数 `log_decorator` 接收一个函数 `func` 作为参数。

```python
def log_decorator(func):
    # 定义一个内层函数 wrapper，它将替代原始的 func
    # wrapper 是一个闭包，它可以访问外部的 func
    def wrapper():
        print(f"准备执行函数: {func.__name__}")
        func()  # 在这里执行原始函数
        print(f"函数 {func.__name__} 执行完毕")

    # 装饰器返回这个包装好的内层函数
    return wrapper
```

#### **步骤 2: 使用装饰器**

```python
@log_decorator
def my_business_logic():
    print("业务逻辑正在执行...")

# 调用这个函数
my_business_logic()
```

**输出结果：**

```
准备执行函数: my_business_logic
业务逻辑正在执行...
函数 my_business_logic 执行完毕
```

你看，我们没有修改 `my_business_logic` 的任何代码，但成功地为它增加了日志功能。

-----

### **4. 升级：让装饰器处理带参数和返回值的函数**

上面的例子太简单了。如果我们的业务函数需要接收参数，并且有返回值怎么办？

我们需要使用 `*args` 和 `**kwargs` 来接收任意参数，并把返回值 `return` 回去。

我们来写一个计算函数执行时间的装饰器：

```python
import time

def timer_decorator(func):
    # 使用 *args 和 **kwargs 接收任意参数
    def wrapper(*args, **kwargs):
        start_time = time.time()
        
        # 将参数传递给原始函数，并接收返回值
        result = func(*args, **kwargs)
        
        end_time = time.time()
        print(f"函数 {func.__name__} 执行耗时: {end_time - start_time:.4f} 秒")
        
        # 将原始函数的返回值返回出去
        return result
    
    return wrapper

@timer_decorator
def calculate_sum(n):
    """计算从1到n的总和"""
    total = 0
    for i in range(n + 1):
        total += i
    return total

# 调用带参数和返回值的函数
final_sum = calculate_sum(1000000)
print(f"计算结果是: {final_sum}")
```

**输出结果：**

```
函数 calculate_sum 执行耗时: 0.0458 秒
计算结果是: 5000000500000
```

-----

### **5. 最佳实践：使用 `functools.wraps`**

你会发现一个问题：被装饰后的函数，它的一些元信息（如函数名 `__name__`、文档字符串 `__doc__`）会丢失。

```python
print(calculate_sum.__name__) # 输出: wrapper (我们期望的是 calculate_sum)
print(calculate_sum.__doc__)  # 输出: None (我们期望的是 "计算从1到n的总和")
```

这是因为我们返回的是 `wrapper` 函数。为了解决这个问题，Python 提供了 `functools.wraps`。

**正确写法：**

```python
import time
from functools import wraps # 导入 wraps

def timer_decorator_pro(func):
    @wraps(func) # 在 wrapper 定义前加上 @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数 {func.__name__} 执行耗时: {end_time - start_time:.4f} 秒")
        return result
    return wrapper

@timer_decorator_pro
def calculate_power(base, exponent):
    """计算一个数的幂"""
    return base ** exponent

print(calculate_power.__name__) # 输出: calculate_power (正确了!)
print(calculate_power.__doc__)  # 输出: 计算一个数的幂 (正确了!)
```

-----

### **6. 总结与实际应用场景**

  * **总结：** 装饰器是一个接收函数、返回增强版函数的特殊函数，`@` 是它的语法糖。它利用了函数是一等公民和闭包的特性，通过 `*args, **kwargs` 处理参数，并通过 `@functools.wraps` 保持原函数的元信息。

  * **常见应用场景：**

      * **日志记录 (Logging):** 自动记录函数调用的入口和出口。
      * **性能测试 (Timing):** 自动计算函数的执行时间。
      * **权限校验 (Authorization):** 在 Web 框架（如 Flask, Django）中，检查用户是否登录或有权访问某个接口。
      * **缓存 (Caching):** 将耗时函数的计算结果缓存起来，下次同样的输入直接返回结果，无需重复计算。
      * **事务处理 (Transaction):** 自动处理数据库的事务开启、提交或回滚。